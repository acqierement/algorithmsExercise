## 动态规划相关题目
 1. 0-1背包问题
 2. 打家劫舍 LeetCode[198. House Robber](https://leetcode.com/problems/house-robber/)
    这题在LeetCode上标记为简单的题目，结果一开始我却无从下手，其实这是一道最简单的动态规划的题目
 3. 计算两个单词编辑距离（比较两个单词的“差异度”）LeetCode[72. Edit Distance](https://leetcode.com/problems/edit-distance/)
 4. 硬币找零 LeetCode[322. Coin Change](https://leetcode.com/problems/coin-change/) 
 

### 计算两个单词编辑距离
这是一道典型的动态规划问题。int cost\[i][j] 表示i个字符转换成j个字符要几次操作。

- 如果第i个字符等于第j个字符（word1.charAt(i) == word2.charAt(j)）那么cost\[i][j] = cost\[i - 1][j - 1].这个很好理解。wo和wo比较，假设我们比较的两个o，相等，那么wo转换成wo就只需要看前面的w转换成w需要几步操作。

- 如果第i个字符不等于第j个字符（word1.charAt(i) != word2.charAt(j)）,那么此时有三种选择：
  - 替换字符，cost\[i][j] = cost\[i - 1][j - 1]，替换了，当前的两个字符肯定相等，所以和前面的情况一样。
  - 增加字符，cost\[i][j] = cost\[i][j - 1]
  - 删除字符，cost\[i][j] = cost\[i - 1][j]

我前面一直不太理解增加和删除怎么来的。现在我们举个例子来看一下。

如果我们要比较wa和wb，此时假设i和j指向a和b，a和b不一样，我们有三种选择，替换不用说了，我们先来看一下增加操作。

我们增加字符肯定是会增加一样的字符，所以就会变成wba和wb比较。但是注意，这里增加并不是在字符串中真的增加，原本i是指向a的，即使这里增加了一个字符，i也还是指向a。所以其实现在计算的是w(b)a转换成wb。此时w(b)a中的b已经和wb中的b匹配了，我们就当做把b删掉，现在就变成了计算wa转换成w所需要的操作次数，wa和w对应的位置是i和j - 1.所以cost\[i][j] = cost\[i][j - 1]

再来看一下删除操作。还是原来的例子wa和wb，我们现在把a删掉，注意这里也并不是真的删掉，i还是指向a的。原本计算wa转换成wb，现在就变成w转换成wb，两个的位置分别是i - 1和j，对应cost\[i][j] = cost\[i - 1][j]

这里我们还可以节省一下空间，不需要二维数组，只需要一维数组和一个变量来存储中间过程。另一个方法就是使用一维数组的

因为cost\[i][j]只与下面三个式子有关。

```java
cost[i - 1][j - 1]
cost[i][j - 1]
cost[i - 1][j]
```

我们把二维数组画出来看一下

```
X 1 1 X
X 1 O X
X X X X
```

O就是我们要求的cost\[i][j]，其余的1就是另外三个式子。所以每次三个值中最小的值就是我们要求的。

左上角的1,也就是cost\[i - 1][j - 1]我们用一个变量prev来存储。剩下的上方的和左边的变量我们可以放在一个一维数组里面。这种方式在动态规划里面很常见。现在我们只探讨一下两个变量的情况

```
X X Q X
X P O X
X X X X
```

我们现在要拿到P和Q的值来计算O，但是只用一个一维数组，来看看怎么实现的。

一维数组依次将每行存进去，但是后面一行会将前面一行覆盖。

我们一维数组先把第一行存进去

```
【X X Q X】
接着放第二行的前两个
【X P Q X】
```

接下去就是要就算O了，O应该放到Q的位置，而P Q都可以拿到，cur[i] = src.main.java.exercise.Math.min(cur[i], cur[i - 1])。
